#!/usr/bin/python

import sys;
import os;

def accessorText (argdict) :
	setterTemp = '''/*! Generated by script */
void %(cls)s::set%(capProp)s (%(typename)s %(prop)s)
{
    if (_%(prop)s != %(prop)s) {
	_%(prop)s = %(prop)s;
	emit %(prop)sChanged(%(prop)s);
    }
}
'''

	getterTemp = '''/*! Generated by script */
%(typename)s %(cls)s::%(prop)s () const
{
    return _%(prop)s;
}
'''
	return "%s\n%s\n" % (
		setterTemp % argdict, 
		getterTemp % argdict
	)

def accessorDecl (argdict) :
	declTemp = '''
    void %(cls)s::set%(capProp)s (%(typename)s %(prop)s);
    %(typename)s %(cls)s::%(prop)s () const;
'''
	return declTemp % argdict

def signalDecl (argdict):
	sigTemp = '    void %(prop)sChanged (%(typename)s %(prop)s);'
	return (sigTemp % argdict) + "\n"

def propMember (argdict):
	memTemp = '    %(typename)s _%(prop)s;'
	return (memTemp % argdict) + "\n"
def propDef (argdict):
	propTemp = '    Q_PROPERTY (%(typename)s %(prop)s READ %(prop)s WRITE set%(capProp)s NOTIFY %(prop)sChanged)'
	return (propTemp % argdict) + "\n"

#Create Accesssor Function IMPL
def createAccessorCpp(filename, argdict):
	try:
		fd = open (filename, "a")
	except:
		print "Can not open file", filename
		fd.close()
		return
	print accessorText (argdict)
	fd.write (accessorText (argdict))

#Create Accessor Declarations
def createAccessorHeader(filename, argdict):
	tempname = '.%s.tmp' % filename
	try:
		rfd = open (filename, "r")
		wfd = open (tempname, "w")
	except:
		print "Can not go on when dealing with input %s, and temp %s" % (filename, tempname)
		return
	context = ''
	prevctx = ''
	propDefed = False
	decled = False
	signaled = False
	memed = False
	classSt = False
	classEd = False
	blc = 0
	for line in rfd:
		lw = False
		sl = line.strip()
		prevctx = context
		if   (sl.startswith('class %s' % argdict['cls'])):
			classSt = True
			context = 'class'
		elif (sl.startswith('public:')):
			context = 'public'
		elif (sl.startswith('public slots:')):
			context = 'public slots'
		elif (sl.startswith('private:') or sl.startswith('protected')):
			context = 'private'
		elif (sl.startswith('signals:')):
			context = 'signals'
		elif (sl.startswith('};')): #Means class ended
			if (classSt):
				classEd = True
			context = ''
		if (classSt and (prevctx != context)):
			if (prevctx == 'public'):
				if (not decled):
					wfd.write (accessorDecl(argdict))
					decled = True
			elif (prevctx == 'private'):
				if (not memed):
					wfd.write (propMember (argdict))
					memed = True
			elif (prevctx == 'signals'):
				if (not signaled):
					wfd.write (signalDecl (argdict))
					signaled = True
			if (context == 'public'):
				wfd.write (line)
				lw = True
				if ((not propDefed)):
					wfd.write (propDef(argdict))
					propDefed = True

		if (classEd):
			if (not propDefed):
				wfd.write ("public: \n")
				wfd.write (propDef(argdict))
				propDefed = True
			if (not decled):
				wfd.write ("public: \n")
				wfd.write (accesorDecl(argdict))
				decled = True
			if (not signaled):
				wfd.write ("signals: \n")
				wfd.write (signalDecl (argdict))
				signaled = True
			if (not memed):
				wfd.write ("private: \n")
				wfd.write (propMember (argdict))
				memed = True
		if (not sl):
			blc = blc + 1
		else:
			if (prevctx != context):
				wfd.write ("\n" * blc)
				blc = 0
			if (not lw):
				wfd.write (line)
	rfd.close()
	wfd.close()
	os.remove (filename)
	os.rename (tempname, filename)
def main():
	try:
		cls, typename, prop = sys.argv[1:]
	except:
		print "Not engouh arguments"
		exit (1)
	capname = prop[0].upper() + prop[1:]
	argdict = dict(cls = cls, capProp = capname, prop = prop, typename = typename)
	cppf = cls.lower() + '.cpp'
	headf = cls.lower() + '.h'
	createAccessorHeader (headf, argdict)
	createAccessorCpp (cppf, argdict)
	
	
if (__name__ == "__main__"): 
	main()
