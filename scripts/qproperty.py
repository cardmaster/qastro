#!/usr/bin/python

import sys;
import os;

def accessorText (argdict) :
	setterTemp = '''/*! Generated by script */
void %(cls)s::set%(capProp)s (%(functypename)s %(prop)s)
{
    if (_%(prop)s != %(prop)s) {
	_%(prop)s = %(prop)s;
	emit %(prop)sChanged(%(prop)s);
    }
}
'''

	getterTemp = '''/*! Generated by script */
%(functypename)s %(cls)s::%(prop)s () const
{
    return _%(prop)s;
}
'''
	return "%s\n%s\n" % (
		setterTemp % argdict, 
		getterTemp % argdict
	)

def accessorDecl (argdict) :
	declTemp = '''
    void set%(capProp)s (%(functypename)s %(prop)s);
    %(functypename)s %(prop)s () const;
'''
	return declTemp % argdict

def signalDecl (argdict):
	sigTemp = '    void %(prop)sChanged (%(typename)s %(prop)s);'
	return (sigTemp % argdict) + "\n"

def propMember (argdict):
	memTemp = '    %(typename)s _%(prop)s;'
	return (memTemp % argdict) + "\n"
def propDef (argdict):
	propTemp = '    Q_PROPERTY (%(typename)s %(prop)s READ %(prop)s WRITE set%(capProp)s NOTIFY %(prop)sChanged)'
	return (propTemp % argdict) + "\n"

class LogWriter(object):
	def __init__(self, filename, mode = "a"):
		self.filename = filename;
		self.logs = []
		self.ln = 0
		if (mode == "a"):
			try: 
				self.ln = open(filename, "r").read().count("\n")
			except:
				self.ln = 0
		try:
			self.fd = open (filename, mode)
		except:
			print "Can not open file", filename
			self.fd.close()
			exit(1)
	def write(self, text):
		self.ln += text.count("\n")
		self.fd.write(text)
	def close(self):
		self.fd.close()
	def logWrite(self, text):
		self.logs.append("@L%d~L%d: \n%s" % (self.ln, self.ln + text.count("\n"), text));
		self.write(text);

#Create Accesssor Function IMPL
def createAccessorCpp(filename, argdict):
	fd = LogWriter(filename, "a")
	fd.logWrite (accessorText (argdict))
	fd.close()
	print "ADD in ", filename, "\n", "\n".join(fd.logs)

#Create Accessor Declarations
def createAccessorHeader(filename, argdict):
	tempname = '.%s.tmp' % filename
	try:
		rfd = open (filename, "r")
	except:
		print "Can not go on when dealing with input %s" % (filename)
		return
	wfd = LogWriter(tempname, "w")
	context = ''
	prevctx = ''
	propDefed = False
	decled = False
	signaled = False
	memed = False
	classSt = False
	classEd = False
	blc = 0
	for line in rfd:
		lw = False
		sl = line.strip()
		prevctx = context
		if   (sl.startswith('class %s' % argdict['cls'])):
			classSt = True
			context = 'class'
		elif (sl.startswith('public:')):
			context = 'public'
		elif (sl.startswith('public slots:')):
			context = 'public slots'
		elif (sl.startswith('private:') or sl.startswith('protected')):
			context = 'private'
		elif (sl.startswith('signals:')):
			context = 'signals'
		elif (sl.startswith('};')): #Means class ended
			if (classSt):
				classEd = True
			context = ''
		if (classSt and (prevctx != context)):
			if (prevctx == 'public'):
				if (not decled):
					wfd.logWrite (accessorDecl(argdict))
					decled = True
			elif (prevctx == 'private'):
				if (not memed):
					wfd.logWrite (propMember (argdict))
					memed = True
			elif (prevctx == 'signals'):
				if (not signaled):
					wfd.logWrite (signalDecl (argdict))
					signaled = True
			if (context == 'public'):
				wfd.write (line)
				lw = True
				if ((not propDefed)):
					wfd.logWrite (propDef(argdict))
					propDefed = True

		if (classEd):
			if (not propDefed):
				wfd.logWrite ("public: \n")
				wfd.logWrite (propDef(argdict))
				propDefed = True
			if (not decled):
				wfd.logWrite ("public: \n")
				wfd.logWrite (accesorDecl(argdict))
				decled = True
			if (not signaled):
				wfd.logWrite ("signals: \n")
				wfd.logWrite (signalDecl (argdict))
				signaled = True
			if (not memed):
				wfd.logWrite ("private: \n")
				wfd.logWrite (propMember (argdict))
				memed = True
		if (not sl):
			blc = blc + 1
		else:
			if (prevctx != context):
				wfd.write ("\n" * blc)
				blc = 0
			if (not lw):
				wfd.write (line)
	rfd.close()
	wfd.close()
	os.remove (filename)
	os.rename (tempname, filename)
	print "Wrote to header:", filename, "\n", "\n".join(wfd.logs)

def main():
	try:
		cls, typename, prop = sys.argv[1:]
	except:
		print "Not engouh arguments"
		exit (1)
	capname = prop[0].upper() + prop[1:]
	argdict = dict(cls = cls, capProp = capname, prop = prop, typename = typename)
	if (typename.startswith('Q')):
		functypename = "const %s &" % typename;
	else:
		functypename = typename;
	argdict['functypename'] = functypename;
	cppf = cls.lower() + '.cpp'
	headf = cls.lower() + '.h'
	createAccessorCpp (cppf, argdict)
	createAccessorHeader (headf, argdict)
	
	
if (__name__ == "__main__"): 
	main()
